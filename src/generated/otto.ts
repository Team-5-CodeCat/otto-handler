// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: otto.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import Long from 'long';
import _m0 from 'protobufjs/minimal';

export const protobufPackage = 'ottoscaler.v1';

/** StageType - Pipeline Stageì˜ íƒ€ìž…ì„ ì •ì˜í•˜ëŠ” Enum */
export enum StageType {
  /** STAGE_TYPE_UNSPECIFIED - Proto3 ê´€ë¡€: 0ì€ ë¯¸ì§€ì •/ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ìž… */
  STAGE_TYPE_UNSPECIFIED = 0,
  /** STAGE_TYPE_BUILD - ë¹Œë“œ ë‹¨ê³„ (ì»´íŒŒì¼, íŒ¨í‚¤ì§• ë“±) */
  STAGE_TYPE_BUILD = 1,
  /** STAGE_TYPE_TEST - í…ŒìŠ¤íŠ¸ ë‹¨ê³„ (ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, í†µí•© í…ŒìŠ¤íŠ¸ ë“±) */
  STAGE_TYPE_TEST = 2,
  /** STAGE_TYPE_DEPLOY - ë°°í¬ ë‹¨ê³„ (ìŠ¤í…Œì´ì§•, í”„ë¡œë•ì…˜ ë°°í¬ ë“±) */
  STAGE_TYPE_DEPLOY = 3,
  /** STAGE_TYPE_SETUP - í™˜ê²½ ì„¤ì • ë‹¨ê³„ (ì´ˆê¸°í™”, ì˜ì¡´ì„± ì„¤ì¹˜ ë“±) */
  STAGE_TYPE_SETUP = 4,
  /** STAGE_TYPE_CLEANUP - ì •ë¦¬ ë‹¨ê³„ (ë¦¬ì†ŒìŠ¤ ì •ë¦¬, ìºì‹œ ì‚­ì œ ë“±) */
  STAGE_TYPE_CLEANUP = 5,
  /** STAGE_TYPE_NOTIFY - ì•Œë¦¼ ë‹¨ê³„ (ì´ë©”ì¼, ìŠ¬ëž™ ì•Œë¦¼ ë“±) */
  STAGE_TYPE_NOTIFY = 6,
  /** STAGE_TYPE_APPROVAL - ìŠ¹ì¸ ëŒ€ê¸° ë‹¨ê³„ (ìˆ˜ë™ ìŠ¹ì¸ í•„ìš”) */
  STAGE_TYPE_APPROVAL = 7,
  /** STAGE_TYPE_CUSTOM - ì‚¬ìš©ìž ì •ì˜ ë‹¨ê³„ (ìœ„ ì¹´í…Œê³ ë¦¬ì— ì†í•˜ì§€ ì•ŠëŠ” ê²½ìš°) */
  STAGE_TYPE_CUSTOM = 100,
  UNRECOGNIZED = -1,
}

/** StageStatus - Pipeline Stage ìƒíƒœ */
export enum StageStatus {
  /** STAGE_PENDING - ëŒ€ê¸° ì¤‘ */
  STAGE_PENDING = 0,
  /** STAGE_RUNNING - ì‹¤í–‰ ì¤‘ */
  STAGE_RUNNING = 1,
  /** STAGE_COMPLETED - ì™„ë£Œ */
  STAGE_COMPLETED = 2,
  /** STAGE_FAILED - ì‹¤íŒ¨ */
  STAGE_FAILED = 3,
  /** STAGE_CANCELLED - ì·¨ì†Œë¨ */
  STAGE_CANCELLED = 4,
  /** STAGE_SKIPPED - ê±´ë„ˆëœ€ (ì´ì „ Stage ì‹¤íŒ¨ë¡œ) */
  STAGE_SKIPPED = 5,
  /** STAGE_RETRYING - ìž¬ì‹œë„ ì¤‘ */
  STAGE_RETRYING = 6,
  UNRECOGNIZED = -1,
}

/**
 * LogEntry - Worker Podì—ì„œ ìƒì„±ë˜ëŠ” ë‹¨ì¼ ë¡œê·¸ ì—”íŠ¸ë¦¬
 *
 * ðŸ“ ë¡œê·¸ êµ¬ì¡° ì„¤ëª…:
 * - Worker Podì˜ stdout/stderrì—ì„œ ìºì¹˜ëœ í•œ ì¤„ì˜ ë¡œê·¸ë¥¼ í‘œí˜„
 * - ì‹œê°„ ì •ë³´ì™€ í•¨ê»˜ êµ¬ì¡°í™”ëœ í˜•íƒœë¡œ ì „ì†¡
 * - NestJS ì„œë²„ì—ì„œ íŒŒì‹±í•˜ì—¬ ì›¹ ì¸í„°íŽ˜ì´ìŠ¤ì— ì‹¤ì‹œê°„ í‘œì‹œ
 *
 * ðŸ” ì‚¬ìš© ì˜ˆì‹œ:
 * {
 *   "worker_id": "otto-agent-1-abc123",
 *   "task_id": "task-456",
 *   "timestamp": "2025-09-01T12:34:56.789Z",
 *   "level": "INFO",
 *   "source": "stdout",
 *   "message": "Task processing started...",
 *   "metadata": {"step": "initialization"}
 * }
 */
export interface LogEntry {
  /**
   * Worker Podì˜ ê³ ìœ  ì‹ë³„ìž (ì˜ˆ: "otto-agent-1-abc123")
   * Main Podì—ì„œ ìƒì„±í•œ Worker Podì˜ ì´ë¦„ê³¼ ì¼ì¹˜í•´ì•¼ í•¨
   */
  workerId: string;
  /**
   * Redis ì´ë²¤íŠ¸ì—ì„œ ì˜¨ ìž‘ì—… ì‹ë³„ìž (ì˜ˆ: "task-456")
   * ì–´ë–¤ scale_up ì´ë²¤íŠ¸ë¡œ ì¸í•´ ìƒì„±ëœ ìž‘ì—…ì¸ì§€ ì¶”ì 
   */
  taskId: string;
  /**
   * ë¡œê·¸ ìƒì„± ì‹œê°„ (RFC3339 í˜•ì‹: "2025-09-01T12:34:56.789Z")
   * Worker Pod ë‚´ë¶€ì—ì„œ ë¡œê·¸ê°€ ì‹¤ì œë¡œ ë°œìƒí•œ ì‹œì 
   */
  timestamp: string;
  /**
   * ë¡œê·¸ ë ˆë²¨ (INFO, ERROR, DEBUG, WARN ë“±)
   * ë¡œê·¸ì˜ ì¤‘ìš”ë„ë‚˜ ìœ í˜•ì„ ë‚˜íƒ€ëƒ„
   */
  level: string;
  /**
   * ë¡œê·¸ ì†ŒìŠ¤ (stdout, stderr)
   * í‘œì¤€ ì¶œë ¥ì¸ì§€ ì—ëŸ¬ ì¶œë ¥ì¸ì§€ êµ¬ë¶„
   */
  source: string;
  /**
   * ì‹¤ì œ ë¡œê·¸ ë©”ì‹œì§€ ë‚´ìš© (cmdì°½ì— ì¶œë ¥ë˜ëŠ” í•œ ì¤„)
   * Worker Podì˜ ìž‘ì—… ì§„í–‰ ìƒí™©, ì—ëŸ¬, ë””ë²„ê·¸ ì •ë³´ ë“±
   */
  message: string;
  /**
   * ì¶”ê°€ ë©”íƒ€ë°ì´í„° (ì„ íƒì )
   * ìž‘ì—… ë‹¨ê³„, íŒŒì¼ëª…, í•¨ìˆ˜ëª… ë“± ë¶€ê°€ ì •ë³´
   */
  metadata: { [key: string]: string };
}

export interface LogEntry_MetadataEntry {
  key: string;
  value: string;
}

/**
 * LogResponse - NestJS ì„œë²„ì—ì„œ Worker Podë¡œì˜ ì‘ë‹µ ë©”ì‹œì§€
 *
 * ðŸ”„ ì‘ë‹µ ì²˜ë¦¬ ë¡œì§:
 * - ACK: ë¡œê·¸ ì„±ê³µì ìœ¼ë¡œ ë°›ìŒ, ë‹¤ìŒ ë¡œê·¸ ì „ì†¡ ê°€ëŠ¥
 * - RETRY: ì¼ì‹œì  ì‹¤íŒ¨, ê°™ì€ ë¡œê·¸ë¥¼ ë‹¤ì‹œ ì „ì†¡ í•„ìš”
 * - DROP: ì˜êµ¬ì  ì‹¤íŒ¨, í•´ë‹¹ ë¡œê·¸ í¬ê¸°í•˜ê³  ë‹¤ìŒìœ¼ë¡œ ì§„í–‰
 *
 * ðŸ“Š ë°±í”„ë ˆì…”(Backpressure) ì²˜ë¦¬:
 * - ì„œë²„ ê³¼ë¶€í•˜ ì‹œ RETRY ì‘ë‹µìœ¼ë¡œ Worker Pod ì „ì†¡ ì†ë„ ì¡°ì ˆ
 * - sequence ë²ˆí˜¸ë¡œ ë¡œê·¸ ìˆœì„œ ë³´ìž¥
 */
export interface LogResponse {
  /** ë¡œê·¸ ì²˜ë¦¬ ê²°ê³¼ ìƒíƒœ */
  status: LogResponse_Status;
  /**
   * ë””ë²„ê¹…ìš© ë©”ì‹œì§€ (ì„ íƒì )
   * ì—ëŸ¬ ì´ìœ ë‚˜ ì¶”ê°€ ì •ë³´ ì œê³µ
   */
  message: string;
  /**
   * ìˆœì„œ ë³´ìž¥ì„ ìœ„í•œ ì‹œí€€ìŠ¤ ë²ˆí˜¸ (ì„ íƒì )
   * ë¡œê·¸ ì „ì†¡ ìˆœì„œì™€ ì²˜ë¦¬ ìˆœì„œ ë§¤ì¹­
   */
  sequence: number;
}

/**
 * Status - ë¡œê·¸ ì²˜ë¦¬ ê²°ê³¼ ìƒíƒœ
 *
 * âœ… ACK (0): ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë¨
 * ðŸ”„ RETRY (1): ì¼ì‹œì  ì˜¤ë¥˜, ìž¬ì‹œë„ í•„ìš” (ë„¤íŠ¸ì›Œí¬ ì§€ì—°, ì„œë²„ ë¶€í•˜ ë“±)
 * âŒ DROP (2): ì˜êµ¬ì  ì˜¤ë¥˜, í•´ë‹¹ ë¡œê·¸ í¬ê¸° (ìž˜ëª»ëœ í˜•ì‹, ê¶Œí•œ ì—†ìŒ ë“±)
 */
export enum LogResponse_Status {
  /** ACK - ì„±ê³µì ìœ¼ë¡œ ë°›ê³  ì²˜ë¦¬í•¨ */
  ACK = 0,
  /** RETRY - ì¼ì‹œì  ì‹¤íŒ¨, ìž¬ì‹œë„ ìš”ì²­ */
  RETRY = 1,
  /** DROP - ì˜êµ¬ì  ì‹¤íŒ¨, ë¡œê·¸ í¬ê¸° */
  DROP = 2,
  UNRECOGNIZED = -1,
}

/** WorkerRegistration contains information about a starting worker */
export interface WorkerRegistration {
  /** Worker pod identifier */
  workerId: string;
  /** Task identifier this worker is handling */
  taskId: string;
  /** Worker pod metadata */
  metadata: WorkerMetadata | undefined;
  /** NestJS server endpoint (for health checks) */
  serverEndpoint: string;
}

/** WorkerMetadata contains Kubernetes pod information */
export interface WorkerMetadata {
  /** Pod name in Kubernetes */
  podName: string;
  /** Kubernetes namespace */
  namespace: string;
  /** Node where pod is running */
  nodeName: string;
  /** Pod creation timestamp */
  createdAt: string;
  /** Labels applied to the pod */
  labels: { [key: string]: string };
}

export interface WorkerMetadata_LabelsEntry {
  key: string;
  value: string;
}

/** RegistrationResponse confirms worker registration */
export interface RegistrationResponse {
  status: RegistrationResponse_Status;
  message: string;
  /** Server-assigned session ID for this worker */
  sessionId: string;
  /** Recommended logging configuration */
  config: LoggingConfig | undefined;
}

export enum RegistrationResponse_Status {
  SUCCESS = 0,
  ALREADY_REGISTERED = 1,
  SERVER_FULL = 2,
  INVALID_REQUEST = 3,
  UNRECOGNIZED = -1,
}

/** LoggingConfig contains server preferences for logging */
export interface LoggingConfig {
  /** Maximum logs per second from this worker */
  rateLimit: number;
  /** Buffer size for batching logs */
  bufferSize: number;
  /** Maximum message size in bytes */
  maxMessageSize: number;
  /** Whether to include full metadata */
  includeMetadata: boolean;
}

/** ScaleRequest - ìŠ¤ì¼€ì¼ë§ ìš”ì²­ ë©”ì‹œì§€ */
export interface ScaleRequest {
  /** ìž‘ì—… ê³ ìœ  ì‹ë³„ìž (CI/CD ìž‘ì—… ID) */
  taskId: string;
  /** Git ì €ìž¥ì†Œ URL */
  repository: string;
  /** Git ì»¤ë°‹ SHA */
  commitSha: string;
  /** ìŠ¤ì¼€ì¼ë§í•  Worker Pod ìˆ˜ (scale_up ì‹œ ìƒì„±í•  ìˆ˜, scale_down ì‹œ ëª©í‘œ ìˆ˜) */
  workerCount: number;
  /** CI/CD ë¹Œë“œ ì„¤ì • (í™˜ê²½ ë³€ìˆ˜, ëª…ë ¹ì–´ ë“±) */
  buildConfig: { [key: string]: string };
  /** ìš”ì²­ì„ ì‹œìž‘í•œ ì£¼ì²´ (ì‚¬ìš©ìž ë˜ëŠ” ì‹œìŠ¤í…œ) */
  triggeredBy: string;
  /** ìŠ¤ì¼€ì¼ë§ ìš”ì²­ ì‚¬ìœ  */
  reason: string;
  /** ì¶”ê°€ ë©”íƒ€ë°ì´í„° */
  metadata: { [key: string]: string };
}

export interface ScaleRequest_BuildConfigEntry {
  key: string;
  value: string;
}

export interface ScaleRequest_MetadataEntry {
  key: string;
  value: string;
}

/** ScaleResponse - ìŠ¤ì¼€ì¼ë§ ì‘ë‹µ ë©”ì‹œì§€ */
export interface ScaleResponse {
  /** ì‘ë‹µ ìƒíƒœ */
  status: ScaleResponse_Status;
  /** ì‘ë‹µ ë©”ì‹œì§€ (ì—ëŸ¬ ì •ë³´ ë˜ëŠ” ì„±ê³µ ë©”ì‹œì§€) */
  message: string;
  /** ì‹¤ì œë¡œ ì²˜ë¦¬ëœ Worker Pod ìˆ˜ */
  processedCount: number;
  /** ìƒì„±/ì‚­ì œëœ Worker Pod ëª©ë¡ */
  workerPodNames: string[];
  /** ì²˜ë¦¬ ì‹œìž‘ ì‹œê°„ (RFC3339 í˜•ì‹) */
  startedAt: string;
  /** ì²˜ë¦¬ ì™„ë£Œ ì‹œê°„ (RFC3339 í˜•ì‹) */
  completedAt: string;
}

export enum ScaleResponse_Status {
  /** SUCCESS - ì„±ê³µ */
  SUCCESS = 0,
  /** FAILED - ì‹¤íŒ¨ */
  FAILED = 1,
  /** PARTIAL_SUCCESS - ë¶€ë¶„ ì„±ê³µ (ì¼ë¶€ Podë§Œ ì²˜ë¦¬ë¨) */
  PARTIAL_SUCCESS = 2,
  /** ALREADY_PROCESSED - ì´ë¯¸ ì²˜ë¦¬ëœ ìš”ì²­ */
  ALREADY_PROCESSED = 3,
  UNRECOGNIZED = -1,
}

/** WorkerStatusRequest - Worker ìƒíƒœ ì¡°íšŒ ìš”ì²­ */
export interface WorkerStatusRequest {
  /** íŠ¹ì • ìž‘ì—… IDë¡œ í•„í„°ë§ (ë¹„ì–´ìžˆìœ¼ë©´ ì „ì²´ ì¡°íšŒ) */
  taskId: string;
  /** íŠ¹ì • Worker Pod ì´ë¦„ìœ¼ë¡œ í•„í„°ë§ */
  workerPodName: string;
  /** ìƒíƒœë¡œ í•„í„°ë§ ("running", "pending", "succeeded", "failed") */
  statusFilter: string;
}

/** WorkerStatusResponse - Worker ìƒíƒœ ì¡°íšŒ ì‘ë‹µ */
export interface WorkerStatusResponse {
  /** ì „ì²´ Worker Pod ìˆ˜ */
  totalCount: number;
  /** ìƒíƒœë³„ Worker Pod ìˆ˜ */
  runningCount: number;
  pendingCount: number;
  succeededCount: number;
  failedCount: number;
  /** Worker Pod ìƒì„¸ ì •ë³´ ëª©ë¡ */
  workers: WorkerPodStatus[];
}

/** WorkerPodStatus - ê°œë³„ Worker Pod ìƒíƒœ ì •ë³´ */
export interface WorkerPodStatus {
  /** Pod ì´ë¦„ */
  podName: string;
  /** ìž‘ì—… ID */
  taskId: string;
  /** Pod ìƒíƒœ ("pending", "running", "succeeded", "failed") */
  status: string;
  /** Pod ìƒì„± ì‹œê°„ */
  createdAt: string;
  /** Pod ì‹œìž‘ ì‹œê°„ */
  startedAt: string;
  /** Pod ì™„ë£Œ ì‹œê°„ (ì™„ë£Œëœ ê²½ìš°) */
  completedAt: string;
  /** ì‹¤í–‰ ì¤‘ì¸ ë…¸ë“œ */
  nodeName: string;
  /** Pod IP */
  podIp: string;
  /** ì¶”ê°€ ë¼ë²¨ */
  labels: { [key: string]: string };
  /** ì—ëŸ¬ ë©”ì‹œì§€ (ì‹¤íŒ¨í•œ ê²½ìš°) */
  errorMessage: string;
}

export interface WorkerPodStatus_LabelsEntry {
  key: string;
  value: string;
}

/** WorkerLogEntry - Ottoscalerì—ì„œ Otto-handlerë¡œ ì „ë‹¬í•˜ëŠ” Worker ë¡œê·¸ ì—”íŠ¸ë¦¬ */
export interface WorkerLogEntry {
  /** Worker Podì˜ ê³ ìœ  ì‹ë³„ìž */
  workerId: string;
  /** ìž‘ì—… ì‹ë³„ìž (CI/CD ìž‘ì—… ID) */
  taskId: string;
  /** ë¡œê·¸ ìƒì„± ì‹œê°„ (RFC3339 í˜•ì‹) */
  timestamp: string;
  /** ë¡œê·¸ ë ˆë²¨ (INFO, ERROR, DEBUG, WARN) */
  level: string;
  /** ë¡œê·¸ ì†ŒìŠ¤ (stdout, stderr) */
  source: string;
  /** ì‹¤ì œ ë¡œê·¸ ë©”ì‹œì§€ ë‚´ìš© */
  message: string;
  /** Pod ê´€ë ¨ ë©”íƒ€ë°ì´í„° */
  podMetadata: WorkerMetadata | undefined;
  /** ì¶”ê°€ ë©”íƒ€ë°ì´í„° */
  metadata: { [key: string]: string };
}

export interface WorkerLogEntry_MetadataEntry {
  key: string;
  value: string;
}

/** LogForwardResponse - Otto-handlerì—ì„œ Ottoscalerë¡œì˜ ë¡œê·¸ ì²˜ë¦¬ ì‘ë‹µ */
export interface LogForwardResponse {
  /** ë¡œê·¸ ì²˜ë¦¬ ê²°ê³¼ ìƒíƒœ */
  status: LogForwardResponse_Status;
  /** ì‘ë‹µ ë©”ì‹œì§€ (ì—ëŸ¬ ì •ë³´ ë˜ëŠ” ì„±ê³µ ë©”ì‹œì§€) */
  message: string;
  /** ìˆœì„œ ë³´ìž¥ì„ ìœ„í•œ ì‹œí€€ìŠ¤ ë²ˆí˜¸ */
  sequence: number;
  /** ë°±í”„ë ˆì…” ì œì–´: ë‹¤ìŒ ë¡œê·¸ê¹Œì§€ ëŒ€ê¸° ì‹œê°„ (ms) */
  throttleMs: number;
}

export enum LogForwardResponse_Status {
  /** ACK - ì„±ê³µì ìœ¼ë¡œ ë°›ê³  ì²˜ë¦¬í•¨ */
  ACK = 0,
  /** RETRY - ì¼ì‹œì  ì‹¤íŒ¨, ìž¬ì‹œë„ ìš”ì²­ */
  RETRY = 1,
  /** DROP - ì˜êµ¬ì  ì‹¤íŒ¨, ë¡œê·¸ í¬ê¸° */
  DROP = 2,
  UNRECOGNIZED = -1,
}

/** WorkerStatusNotification - Worker Pod ìƒíƒœ ë³€ê²½ ì•Œë¦¼ */
export interface WorkerStatusNotification {
  /** Worker Pod ì´ë¦„ */
  workerId: string;
  /** ìž‘ì—… ID */
  taskId: string;
  /** ìƒíƒœ íƒ€ìž… */
  status: WorkerStatusNotification_StatusType;
  /** ìƒíƒœ ë³€ê²½ ì‹œê°„ */
  timestamp: string;
  /** ìƒíƒœ ë³€ê²½ ì´ìœ /ë©”ì‹œì§€ */
  reason: string;
  /** ì¶”ê°€ ë©”íƒ€ë°ì´í„° */
  metadata: { [key: string]: string };
}

export enum WorkerStatusNotification_StatusType {
  /** CREATED - Pod ìƒì„±ë¨ */
  CREATED = 0,
  /** RUNNING - Pod ì‹¤í–‰ ì¤‘ */
  RUNNING = 1,
  /** COMPLETED - Pod ì„±ê³µ ì™„ë£Œ */
  COMPLETED = 2,
  /** FAILED - Pod ì‹¤íŒ¨ */
  FAILED = 3,
  /** TERMINATED - Pod ê°•ì œ ì¢…ë£Œ */
  TERMINATED = 4,
  UNRECOGNIZED = -1,
}

export interface WorkerStatusNotification_MetadataEntry {
  key: string;
  value: string;
}

/** WorkerStatusAck - Worker ìƒíƒœ ì•Œë¦¼ì— ëŒ€í•œ ì‘ë‹µ */
export interface WorkerStatusAck {
  status: WorkerStatusAck_Status;
  message: string;
}

export enum WorkerStatusAck_Status {
  /** RECEIVED - ì„±ê³µì ìœ¼ë¡œ ë°›ìŒ */
  RECEIVED = 0,
  /** IGNORED - ë¬´ì‹œë¨ (ì¤‘ë³µ ë“±) */
  IGNORED = 1,
  /** ERROR - ì²˜ë¦¬ ì¤‘ ì—ëŸ¬ */
  ERROR = 2,
  UNRECOGNIZED = -1,
}

/** PipelineRequest - Pipeline ì‹¤í–‰ ìš”ì²­ */
export interface PipelineRequest {
  /** Pipeline ê³ ìœ  ID */
  pipelineId: string;
  /** Pipeline ì´ë¦„ (ì˜ˆ: "Full CI/CD", "Build and Test") */
  name: string;
  /** Pipelineì„ êµ¬ì„±í•˜ëŠ” Stageë“¤ */
  stages: PipelineStage[];
  /** Repository ì •ë³´ */
  repository: string;
  /** Commit SHA */
  commitSha: string;
  /** íŠ¸ë¦¬ê±°í•œ ì‚¬ìš©ìž/ì‹œìŠ¤í…œ */
  triggeredBy: string;
  /** Pipeline ë©”íƒ€ë°ì´í„° */
  metadata: { [key: string]: string };
}

export interface PipelineRequest_MetadataEntry {
  key: string;
  value: string;
}

/** PipelineStage - Pipelineì„ êµ¬ì„±í•˜ëŠ” ê°œë³„ Stage */
export interface PipelineStage {
  /** Stage ID (ì˜ˆ: "build", "unit-test", "deploy-staging") */
  stageId: string;
  /** Stage íƒ€ìž… (Enumìœ¼ë¡œ íƒ€ìž… ì•ˆì •ì„± ë³´ìž¥) */
  type: StageType;
  /** Stage ì´ë¦„ */
  name: string;
  /** ì´ Stageë¥¼ ìœ„í•œ Worker ìˆ˜ */
  workerCount: number;
  /** ì˜ì¡´í•˜ëŠ” Stage ID ëª©ë¡ (ë³‘ë ¬ ì‹¤í–‰ ê°€ëŠ¥ íŒë‹¨ìš©) */
  dependsOn: string[];
  /** Stageë³„ ì„¤ì • (í™˜ê²½ë³€ìˆ˜, íŒŒë¼ë¯¸í„° ë“±) */
  config: { [key: string]: string };
  /** ì‚¬ìš©í•  ì´ë¯¸ì§€ (ë¹„ì–´ìžˆìœ¼ë©´ ê¸°ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©) */
  image: string;
  /** ì‹¤í–‰í•  ëª…ë ¹ì–´ */
  command: string[];
  /** ëª…ë ¹ì–´ ì¸ìž */
  args: string[];
  /** íƒ€ìž„ì•„ì›ƒ (ì´ˆ ë‹¨ìœ„, 0ì´ë©´ ë¬´ì œí•œ) */
  timeoutSeconds: number;
  /** ìž¬ì‹œë„ ì •ì±… */
  retryPolicy: RetryPolicy | undefined;
}

export interface PipelineStage_ConfigEntry {
  key: string;
  value: string;
}

/** RetryPolicy - Stage ì‹¤íŒ¨ ì‹œ ìž¬ì‹œë„ ì •ì±… */
export interface RetryPolicy {
  /** ìµœëŒ€ ìž¬ì‹œë„ íšŸìˆ˜ */
  maxAttempts: number;
  /** ìž¬ì‹œë„ ê°„ê²© (ì´ˆ) */
  retryDelaySeconds: number;
  /** ìž¬ì‹œë„ ê°€ëŠ¥í•œ ì‹¤íŒ¨ ìœ í˜• */
  retryableFailures: string[];
}

/** PipelineProgress - Pipeline ì‹¤í–‰ ì§„í–‰ ìƒí™© */
export interface PipelineProgress {
  /** Pipeline ID */
  pipelineId: string;
  /** í˜„ìž¬ Stage ID */
  stageId: string;
  /** Stage ìƒíƒœ */
  status: StageStatus;
  /** ìƒíƒœ ë©”ì‹œì§€ */
  message: string;
  /** ì´ Stageë¥¼ ìœ„í•´ ìƒì„±ëœ Worker Pod ì´ë¦„ë“¤ */
  workerPodNames: string[];
  /** ì§„í–‰ë¥  (0-100) */
  progressPercentage: number;
  /** íƒ€ìž„ìŠ¤íƒ¬í”„ */
  timestamp: string;
  /** Stage ì‹œìž‘ ì‹œê°„ */
  startedAt: string;
  /** Stage ì™„ë£Œ ì‹œê°„ (ì™„ë£Œëœ ê²½ìš°) */
  completedAt: string;
  /** ì—ëŸ¬ ì •ë³´ (ì‹¤íŒ¨í•œ ê²½ìš°) */
  errorMessage: string;
  /** Stage ë©”íŠ¸ë¦­ */
  metrics: StageMetrics | undefined;
}

/** StageMetrics - Stage ì‹¤í–‰ ë©”íŠ¸ë¦­ */
export interface StageMetrics {
  /** ì‹¤í–‰ ì‹œê°„ (ì´ˆ) */
  durationSeconds: number;
  /** ì„±ê³µí•œ Worker ìˆ˜ */
  successfulWorkers: number;
  /** ì‹¤íŒ¨í•œ Worker ìˆ˜ */
  failedWorkers: number;
  /** ì´ Worker ìˆ˜ */
  totalWorkers: number;
  /** CPU ì‚¬ìš©ëŸ‰ (í‰ê· ) */
  avgCpuUsage: number;
  /** ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (í‰ê· , MB) */
  avgMemoryMb: number;
}

function createBaseLogEntry(): LogEntry {
  return {
    workerId: '',
    taskId: '',
    timestamp: '',
    level: '',
    source: '',
    message: '',
    metadata: {},
  };
}

export const LogEntry = {
  encode(
    message: LogEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.timestamp !== '') {
      writer.uint32(26).string(message.timestamp);
    }
    if (message.level !== '') {
      writer.uint32(34).string(message.level);
    }
    if (message.source !== '') {
      writer.uint32(42).string(message.source);
    }
    if (message.message !== '') {
      writer.uint32(50).string(message.message);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      LogEntry_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(58).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.level = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = LogEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogEntry>): LogEntry {
    return LogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntry>): LogEntry {
    const message = createBaseLogEntry();
    message.workerId = object.workerId ?? '';
    message.taskId = object.taskId ?? '';
    message.timestamp = object.timestamp ?? '';
    message.level = object.level ?? '';
    message.source = object.source ?? '';
    message.message = object.message ?? '';
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseLogEntry_MetadataEntry(): LogEntry_MetadataEntry {
  return { key: '', value: '' };
}

export const LogEntry_MetadataEntry = {
  encode(
    message: LogEntry_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): LogEntry_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogEntry_MetadataEntry>): LogEntry_MetadataEntry {
    return LogEntry_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LogEntry_MetadataEntry>,
  ): LogEntry_MetadataEntry {
    const message = createBaseLogEntry_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseLogResponse(): LogResponse {
  return { status: 0, message: '', sequence: 0 };
}

export const LogResponse = {
  encode(
    message: LogResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).int64(message.sequence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequence = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogResponse>): LogResponse {
    return LogResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogResponse>): LogResponse {
    const message = createBaseLogResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBaseWorkerRegistration(): WorkerRegistration {
  return { workerId: '', taskId: '', metadata: undefined, serverEndpoint: '' };
}

export const WorkerRegistration = {
  encode(
    message: WorkerRegistration,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.metadata !== undefined) {
      WorkerMetadata.encode(
        message.metadata,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.serverEndpoint !== '') {
      writer.uint32(34).string(message.serverEndpoint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerRegistration {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = WorkerMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serverEndpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerRegistration>): WorkerRegistration {
    return WorkerRegistration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerRegistration>): WorkerRegistration {
    const message = createBaseWorkerRegistration();
    message.workerId = object.workerId ?? '';
    message.taskId = object.taskId ?? '';
    message.metadata =
      object.metadata !== undefined && object.metadata !== null
        ? WorkerMetadata.fromPartial(object.metadata)
        : undefined;
    message.serverEndpoint = object.serverEndpoint ?? '';
    return message;
  },
};

function createBaseWorkerMetadata(): WorkerMetadata {
  return {
    podName: '',
    namespace: '',
    nodeName: '',
    createdAt: '',
    labels: {},
  };
}

export const WorkerMetadata = {
  encode(
    message: WorkerMetadata,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.podName !== '') {
      writer.uint32(10).string(message.podName);
    }
    if (message.namespace !== '') {
      writer.uint32(18).string(message.namespace);
    }
    if (message.nodeName !== '') {
      writer.uint32(26).string(message.nodeName);
    }
    if (message.createdAt !== '') {
      writer.uint32(34).string(message.createdAt);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      WorkerMetadata_LabelsEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerMetadata {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.podName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = WorkerMetadata_LabelsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerMetadata>): WorkerMetadata {
    return WorkerMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerMetadata>): WorkerMetadata {
    const message = createBaseWorkerMetadata();
    message.podName = object.podName ?? '';
    message.namespace = object.namespace ?? '';
    message.nodeName = object.nodeName ?? '';
    message.createdAt = object.createdAt ?? '';
    message.labels = Object.entries(object.labels ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorkerMetadata_LabelsEntry(): WorkerMetadata_LabelsEntry {
  return { key: '', value: '' };
}

export const WorkerMetadata_LabelsEntry = {
  encode(
    message: WorkerMetadata_LabelsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerMetadata_LabelsEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerMetadata_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WorkerMetadata_LabelsEntry>,
  ): WorkerMetadata_LabelsEntry {
    return WorkerMetadata_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerMetadata_LabelsEntry>,
  ): WorkerMetadata_LabelsEntry {
    const message = createBaseWorkerMetadata_LabelsEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseRegistrationResponse(): RegistrationResponse {
  return { status: 0, message: '', sessionId: '', config: undefined };
}

export const RegistrationResponse = {
  encode(
    message: RegistrationResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    if (message.sessionId !== '') {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.config !== undefined) {
      LoggingConfig.encode(message.config, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RegistrationResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.config = LoggingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RegistrationResponse>): RegistrationResponse {
    return RegistrationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegistrationResponse>): RegistrationResponse {
    const message = createBaseRegistrationResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    message.sessionId = object.sessionId ?? '';
    message.config =
      object.config !== undefined && object.config !== null
        ? LoggingConfig.fromPartial(object.config)
        : undefined;
    return message;
  },
};

function createBaseLoggingConfig(): LoggingConfig {
  return {
    rateLimit: 0,
    bufferSize: 0,
    maxMessageSize: 0,
    includeMetadata: false,
  };
}

export const LoggingConfig = {
  encode(
    message: LoggingConfig,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.rateLimit !== 0) {
      writer.uint32(8).int32(message.rateLimit);
    }
    if (message.bufferSize !== 0) {
      writer.uint32(16).int32(message.bufferSize);
    }
    if (message.maxMessageSize !== 0) {
      writer.uint32(24).int32(message.maxMessageSize);
    }
    if (message.includeMetadata !== false) {
      writer.uint32(32).bool(message.includeMetadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoggingConfig {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rateLimit = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bufferSize = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxMessageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeMetadata = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LoggingConfig>): LoggingConfig {
    return LoggingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggingConfig>): LoggingConfig {
    const message = createBaseLoggingConfig();
    message.rateLimit = object.rateLimit ?? 0;
    message.bufferSize = object.bufferSize ?? 0;
    message.maxMessageSize = object.maxMessageSize ?? 0;
    message.includeMetadata = object.includeMetadata ?? false;
    return message;
  },
};

function createBaseScaleRequest(): ScaleRequest {
  return {
    taskId: '',
    repository: '',
    commitSha: '',
    workerCount: 0,
    buildConfig: {},
    triggeredBy: '',
    reason: '',
    metadata: {},
  };
}

export const ScaleRequest = {
  encode(
    message: ScaleRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.taskId !== '') {
      writer.uint32(10).string(message.taskId);
    }
    if (message.repository !== '') {
      writer.uint32(18).string(message.repository);
    }
    if (message.commitSha !== '') {
      writer.uint32(26).string(message.commitSha);
    }
    if (message.workerCount !== 0) {
      writer.uint32(32).int32(message.workerCount);
    }
    Object.entries(message.buildConfig).forEach(([key, value]) => {
      ScaleRequest_BuildConfigEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).ldelim();
    });
    if (message.triggeredBy !== '') {
      writer.uint32(50).string(message.triggeredBy);
    }
    if (message.reason !== '') {
      writer.uint32(58).string(message.reason);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ScaleRequest_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(66).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScaleRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commitSha = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.workerCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ScaleRequest_BuildConfigEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry5.value !== undefined) {
            message.buildConfig[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = ScaleRequest_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScaleRequest>): ScaleRequest {
    return ScaleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScaleRequest>): ScaleRequest {
    const message = createBaseScaleRequest();
    message.taskId = object.taskId ?? '';
    message.repository = object.repository ?? '';
    message.commitSha = object.commitSha ?? '';
    message.workerCount = object.workerCount ?? 0;
    message.buildConfig = Object.entries(object.buildConfig ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.triggeredBy = object.triggeredBy ?? '';
    message.reason = object.reason ?? '';
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseScaleRequest_BuildConfigEntry(): ScaleRequest_BuildConfigEntry {
  return { key: '', value: '' };
}

export const ScaleRequest_BuildConfigEntry = {
  encode(
    message: ScaleRequest_BuildConfigEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ScaleRequest_BuildConfigEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleRequest_BuildConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<ScaleRequest_BuildConfigEntry>,
  ): ScaleRequest_BuildConfigEntry {
    return ScaleRequest_BuildConfigEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ScaleRequest_BuildConfigEntry>,
  ): ScaleRequest_BuildConfigEntry {
    const message = createBaseScaleRequest_BuildConfigEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseScaleRequest_MetadataEntry(): ScaleRequest_MetadataEntry {
  return { key: '', value: '' };
}

export const ScaleRequest_MetadataEntry = {
  encode(
    message: ScaleRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ScaleRequest_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<ScaleRequest_MetadataEntry>,
  ): ScaleRequest_MetadataEntry {
    return ScaleRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ScaleRequest_MetadataEntry>,
  ): ScaleRequest_MetadataEntry {
    const message = createBaseScaleRequest_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseScaleResponse(): ScaleResponse {
  return {
    status: 0,
    message: '',
    processedCount: 0,
    workerPodNames: [],
    startedAt: '',
    completedAt: '',
  };
}

export const ScaleResponse = {
  encode(
    message: ScaleResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    if (message.processedCount !== 0) {
      writer.uint32(24).int32(message.processedCount);
    }
    for (const v of message.workerPodNames) {
      writer.uint32(34).string(v!);
    }
    if (message.startedAt !== '') {
      writer.uint32(42).string(message.startedAt);
    }
    if (message.completedAt !== '') {
      writer.uint32(50).string(message.completedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScaleResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerPodNames.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.completedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ScaleResponse>): ScaleResponse {
    return ScaleResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScaleResponse>): ScaleResponse {
    const message = createBaseScaleResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    message.processedCount = object.processedCount ?? 0;
    message.workerPodNames = object.workerPodNames?.map((e) => e) || [];
    message.startedAt = object.startedAt ?? '';
    message.completedAt = object.completedAt ?? '';
    return message;
  },
};

function createBaseWorkerStatusRequest(): WorkerStatusRequest {
  return { taskId: '', workerPodName: '', statusFilter: '' };
}

export const WorkerStatusRequest = {
  encode(
    message: WorkerStatusRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.taskId !== '') {
      writer.uint32(10).string(message.taskId);
    }
    if (message.workerPodName !== '') {
      writer.uint32(18).string(message.workerPodName);
    }
    if (message.statusFilter !== '') {
      writer.uint32(26).string(message.statusFilter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerStatusRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workerPodName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusFilter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerStatusRequest>): WorkerStatusRequest {
    return WorkerStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerStatusRequest>): WorkerStatusRequest {
    const message = createBaseWorkerStatusRequest();
    message.taskId = object.taskId ?? '';
    message.workerPodName = object.workerPodName ?? '';
    message.statusFilter = object.statusFilter ?? '';
    return message;
  },
};

function createBaseWorkerStatusResponse(): WorkerStatusResponse {
  return {
    totalCount: 0,
    runningCount: 0,
    pendingCount: 0,
    succeededCount: 0,
    failedCount: 0,
    workers: [],
  };
}

export const WorkerStatusResponse = {
  encode(
    message: WorkerStatusResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.totalCount !== 0) {
      writer.uint32(8).int32(message.totalCount);
    }
    if (message.runningCount !== 0) {
      writer.uint32(16).int32(message.runningCount);
    }
    if (message.pendingCount !== 0) {
      writer.uint32(24).int32(message.pendingCount);
    }
    if (message.succeededCount !== 0) {
      writer.uint32(32).int32(message.succeededCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(40).int32(message.failedCount);
    }
    for (const v of message.workers) {
      WorkerPodStatus.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerStatusResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.runningCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pendingCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.succeededCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.workers.push(WorkerPodStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerStatusResponse>): WorkerStatusResponse {
    return WorkerStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerStatusResponse>): WorkerStatusResponse {
    const message = createBaseWorkerStatusResponse();
    message.totalCount = object.totalCount ?? 0;
    message.runningCount = object.runningCount ?? 0;
    message.pendingCount = object.pendingCount ?? 0;
    message.succeededCount = object.succeededCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    message.workers =
      object.workers?.map((e) => WorkerPodStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkerPodStatus(): WorkerPodStatus {
  return {
    podName: '',
    taskId: '',
    status: '',
    createdAt: '',
    startedAt: '',
    completedAt: '',
    nodeName: '',
    podIp: '',
    labels: {},
    errorMessage: '',
  };
}

export const WorkerPodStatus = {
  encode(
    message: WorkerPodStatus,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.podName !== '') {
      writer.uint32(10).string(message.podName);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.status !== '') {
      writer.uint32(26).string(message.status);
    }
    if (message.createdAt !== '') {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.startedAt !== '') {
      writer.uint32(42).string(message.startedAt);
    }
    if (message.completedAt !== '') {
      writer.uint32(50).string(message.completedAt);
    }
    if (message.nodeName !== '') {
      writer.uint32(58).string(message.nodeName);
    }
    if (message.podIp !== '') {
      writer.uint32(66).string(message.podIp);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      WorkerPodStatus_LabelsEntry.encode(
        { key: key as any, value },
        writer.uint32(74).fork(),
      ).ldelim();
    });
    if (message.errorMessage !== '') {
      writer.uint32(82).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerPodStatus {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerPodStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.podName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.podIp = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = WorkerPodStatus_LabelsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerPodStatus>): WorkerPodStatus {
    return WorkerPodStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerPodStatus>): WorkerPodStatus {
    const message = createBaseWorkerPodStatus();
    message.podName = object.podName ?? '';
    message.taskId = object.taskId ?? '';
    message.status = object.status ?? '';
    message.createdAt = object.createdAt ?? '';
    message.startedAt = object.startedAt ?? '';
    message.completedAt = object.completedAt ?? '';
    message.nodeName = object.nodeName ?? '';
    message.podIp = object.podIp ?? '';
    message.labels = Object.entries(object.labels ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.errorMessage = object.errorMessage ?? '';
    return message;
  },
};

function createBaseWorkerPodStatus_LabelsEntry(): WorkerPodStatus_LabelsEntry {
  return { key: '', value: '' };
}

export const WorkerPodStatus_LabelsEntry = {
  encode(
    message: WorkerPodStatus_LabelsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerPodStatus_LabelsEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerPodStatus_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WorkerPodStatus_LabelsEntry>,
  ): WorkerPodStatus_LabelsEntry {
    return WorkerPodStatus_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerPodStatus_LabelsEntry>,
  ): WorkerPodStatus_LabelsEntry {
    const message = createBaseWorkerPodStatus_LabelsEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseWorkerLogEntry(): WorkerLogEntry {
  return {
    workerId: '',
    taskId: '',
    timestamp: '',
    level: '',
    source: '',
    message: '',
    podMetadata: undefined,
    metadata: {},
  };
}

export const WorkerLogEntry = {
  encode(
    message: WorkerLogEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.timestamp !== '') {
      writer.uint32(26).string(message.timestamp);
    }
    if (message.level !== '') {
      writer.uint32(34).string(message.level);
    }
    if (message.source !== '') {
      writer.uint32(42).string(message.source);
    }
    if (message.message !== '') {
      writer.uint32(50).string(message.message);
    }
    if (message.podMetadata !== undefined) {
      WorkerMetadata.encode(
        message.podMetadata,
        writer.uint32(58).fork(),
      ).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      WorkerLogEntry_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(66).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerLogEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.level = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.podMetadata = WorkerMetadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = WorkerLogEntry_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerLogEntry>): WorkerLogEntry {
    return WorkerLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerLogEntry>): WorkerLogEntry {
    const message = createBaseWorkerLogEntry();
    message.workerId = object.workerId ?? '';
    message.taskId = object.taskId ?? '';
    message.timestamp = object.timestamp ?? '';
    message.level = object.level ?? '';
    message.source = object.source ?? '';
    message.message = object.message ?? '';
    message.podMetadata =
      object.podMetadata !== undefined && object.podMetadata !== null
        ? WorkerMetadata.fromPartial(object.podMetadata)
        : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorkerLogEntry_MetadataEntry(): WorkerLogEntry_MetadataEntry {
  return { key: '', value: '' };
}

export const WorkerLogEntry_MetadataEntry = {
  encode(
    message: WorkerLogEntry_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerLogEntry_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerLogEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WorkerLogEntry_MetadataEntry>,
  ): WorkerLogEntry_MetadataEntry {
    return WorkerLogEntry_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerLogEntry_MetadataEntry>,
  ): WorkerLogEntry_MetadataEntry {
    const message = createBaseWorkerLogEntry_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseLogForwardResponse(): LogForwardResponse {
  return { status: 0, message: '', sequence: 0, throttleMs: 0 };
}

export const LogForwardResponse = {
  encode(
    message: LogForwardResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).int64(message.sequence);
    }
    if (message.throttleMs !== 0) {
      writer.uint32(32).int32(message.throttleMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogForwardResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogForwardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequence = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.throttleMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogForwardResponse>): LogForwardResponse {
    return LogForwardResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogForwardResponse>): LogForwardResponse {
    const message = createBaseLogForwardResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    message.sequence = object.sequence ?? 0;
    message.throttleMs = object.throttleMs ?? 0;
    return message;
  },
};

function createBaseWorkerStatusNotification(): WorkerStatusNotification {
  return {
    workerId: '',
    taskId: '',
    status: 0,
    timestamp: '',
    reason: '',
    metadata: {},
  };
}

export const WorkerStatusNotification = {
  encode(
    message: WorkerStatusNotification,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.timestamp !== '') {
      writer.uint32(34).string(message.timestamp);
    }
    if (message.reason !== '') {
      writer.uint32(42).string(message.reason);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      WorkerStatusNotification_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerStatusNotification {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStatusNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = WorkerStatusNotification_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WorkerStatusNotification>,
  ): WorkerStatusNotification {
    return WorkerStatusNotification.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerStatusNotification>,
  ): WorkerStatusNotification {
    const message = createBaseWorkerStatusNotification();
    message.workerId = object.workerId ?? '';
    message.taskId = object.taskId ?? '';
    message.status = object.status ?? 0;
    message.timestamp = object.timestamp ?? '';
    message.reason = object.reason ?? '';
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorkerStatusNotification_MetadataEntry(): WorkerStatusNotification_MetadataEntry {
  return { key: '', value: '' };
}

export const WorkerStatusNotification_MetadataEntry = {
  encode(
    message: WorkerStatusNotification_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WorkerStatusNotification_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStatusNotification_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<WorkerStatusNotification_MetadataEntry>,
  ): WorkerStatusNotification_MetadataEntry {
    return WorkerStatusNotification_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerStatusNotification_MetadataEntry>,
  ): WorkerStatusNotification_MetadataEntry {
    const message = createBaseWorkerStatusNotification_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseWorkerStatusAck(): WorkerStatusAck {
  return { status: 0, message: '' };
}

export const WorkerStatusAck = {
  encode(
    message: WorkerStatusAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkerStatusAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStatusAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerStatusAck>): WorkerStatusAck {
    return WorkerStatusAck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerStatusAck>): WorkerStatusAck {
    const message = createBaseWorkerStatusAck();
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    return message;
  },
};

function createBasePipelineRequest(): PipelineRequest {
  return {
    pipelineId: '',
    name: '',
    stages: [],
    repository: '',
    commitSha: '',
    triggeredBy: '',
    metadata: {},
  };
}

export const PipelineRequest = {
  encode(
    message: PipelineRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pipelineId !== '') {
      writer.uint32(10).string(message.pipelineId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.stages) {
      PipelineStage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.repository !== '') {
      writer.uint32(34).string(message.repository);
    }
    if (message.commitSha !== '') {
      writer.uint32(42).string(message.commitSha);
    }
    if (message.triggeredBy !== '') {
      writer.uint32(50).string(message.triggeredBy);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PipelineRequest_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(58).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PipelineRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stages.push(PipelineStage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.commitSha = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = PipelineRequest_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PipelineRequest>): PipelineRequest {
    return PipelineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PipelineRequest>): PipelineRequest {
    const message = createBasePipelineRequest();
    message.pipelineId = object.pipelineId ?? '';
    message.name = object.name ?? '';
    message.stages =
      object.stages?.map((e) => PipelineStage.fromPartial(e)) || [];
    message.repository = object.repository ?? '';
    message.commitSha = object.commitSha ?? '';
    message.triggeredBy = object.triggeredBy ?? '';
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePipelineRequest_MetadataEntry(): PipelineRequest_MetadataEntry {
  return { key: '', value: '' };
}

export const PipelineRequest_MetadataEntry = {
  encode(
    message: PipelineRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): PipelineRequest_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<PipelineRequest_MetadataEntry>,
  ): PipelineRequest_MetadataEntry {
    return PipelineRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PipelineRequest_MetadataEntry>,
  ): PipelineRequest_MetadataEntry {
    const message = createBasePipelineRequest_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBasePipelineStage(): PipelineStage {
  return {
    stageId: '',
    type: 0,
    name: '',
    workerCount: 0,
    dependsOn: [],
    config: {},
    image: '',
    command: [],
    args: [],
    timeoutSeconds: 0,
    retryPolicy: undefined,
  };
}

export const PipelineStage = {
  encode(
    message: PipelineStage,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.stageId !== '') {
      writer.uint32(10).string(message.stageId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.name !== '') {
      writer.uint32(26).string(message.name);
    }
    if (message.workerCount !== 0) {
      writer.uint32(32).int32(message.workerCount);
    }
    for (const v of message.dependsOn) {
      writer.uint32(42).string(v!);
    }
    Object.entries(message.config).forEach(([key, value]) => {
      PipelineStage_ConfigEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).ldelim();
    });
    if (message.image !== '') {
      writer.uint32(58).string(message.image);
    }
    for (const v of message.command) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.args) {
      writer.uint32(74).string(v!);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(80).int32(message.timeoutSeconds);
    }
    if (message.retryPolicy !== undefined) {
      RetryPolicy.encode(
        message.retryPolicy,
        writer.uint32(90).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PipelineStage {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stageId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.workerCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dependsOn.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = PipelineStage_ConfigEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry6.value !== undefined) {
            message.config[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.image = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.command.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.retryPolicy = RetryPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PipelineStage>): PipelineStage {
    return PipelineStage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PipelineStage>): PipelineStage {
    const message = createBasePipelineStage();
    message.stageId = object.stageId ?? '';
    message.type = object.type ?? 0;
    message.name = object.name ?? '';
    message.workerCount = object.workerCount ?? 0;
    message.dependsOn = object.dependsOn?.map((e) => e) || [];
    message.config = Object.entries(object.config ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.image = object.image ?? '';
    message.command = object.command?.map((e) => e) || [];
    message.args = object.args?.map((e) => e) || [];
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.retryPolicy =
      object.retryPolicy !== undefined && object.retryPolicy !== null
        ? RetryPolicy.fromPartial(object.retryPolicy)
        : undefined;
    return message;
  },
};

function createBasePipelineStage_ConfigEntry(): PipelineStage_ConfigEntry {
  return { key: '', value: '' };
}

export const PipelineStage_ConfigEntry = {
  encode(
    message: PipelineStage_ConfigEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): PipelineStage_ConfigEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineStage_ConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<PipelineStage_ConfigEntry>,
  ): PipelineStage_ConfigEntry {
    return PipelineStage_ConfigEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PipelineStage_ConfigEntry>,
  ): PipelineStage_ConfigEntry {
    const message = createBasePipelineStage_ConfigEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseRetryPolicy(): RetryPolicy {
  return { maxAttempts: 0, retryDelaySeconds: 0, retryableFailures: [] };
}

export const RetryPolicy = {
  encode(
    message: RetryPolicy,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.maxAttempts !== 0) {
      writer.uint32(8).int32(message.maxAttempts);
    }
    if (message.retryDelaySeconds !== 0) {
      writer.uint32(16).int32(message.retryDelaySeconds);
    }
    for (const v of message.retryableFailures) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryPolicy {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.retryDelaySeconds = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryableFailures.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RetryPolicy>): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryPolicy>): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.maxAttempts = object.maxAttempts ?? 0;
    message.retryDelaySeconds = object.retryDelaySeconds ?? 0;
    message.retryableFailures = object.retryableFailures?.map((e) => e) || [];
    return message;
  },
};

function createBasePipelineProgress(): PipelineProgress {
  return {
    pipelineId: '',
    stageId: '',
    status: 0,
    message: '',
    workerPodNames: [],
    progressPercentage: 0,
    timestamp: '',
    startedAt: '',
    completedAt: '',
    errorMessage: '',
    metrics: undefined,
  };
}

export const PipelineProgress = {
  encode(
    message: PipelineProgress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pipelineId !== '') {
      writer.uint32(10).string(message.pipelineId);
    }
    if (message.stageId !== '') {
      writer.uint32(18).string(message.stageId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.message !== '') {
      writer.uint32(34).string(message.message);
    }
    for (const v of message.workerPodNames) {
      writer.uint32(42).string(v!);
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(48).int32(message.progressPercentage);
    }
    if (message.timestamp !== '') {
      writer.uint32(58).string(message.timestamp);
    }
    if (message.startedAt !== '') {
      writer.uint32(66).string(message.startedAt);
    }
    if (message.completedAt !== '') {
      writer.uint32(74).string(message.completedAt);
    }
    if (message.errorMessage !== '') {
      writer.uint32(82).string(message.errorMessage);
    }
    if (message.metrics !== undefined) {
      StageMetrics.encode(message.metrics, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PipelineProgress {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stageId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workerPodNames.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progressPercentage = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.metrics = StageMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PipelineProgress>): PipelineProgress {
    return PipelineProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PipelineProgress>): PipelineProgress {
    const message = createBasePipelineProgress();
    message.pipelineId = object.pipelineId ?? '';
    message.stageId = object.stageId ?? '';
    message.status = object.status ?? 0;
    message.message = object.message ?? '';
    message.workerPodNames = object.workerPodNames?.map((e) => e) || [];
    message.progressPercentage = object.progressPercentage ?? 0;
    message.timestamp = object.timestamp ?? '';
    message.startedAt = object.startedAt ?? '';
    message.completedAt = object.completedAt ?? '';
    message.errorMessage = object.errorMessage ?? '';
    message.metrics =
      object.metrics !== undefined && object.metrics !== null
        ? StageMetrics.fromPartial(object.metrics)
        : undefined;
    return message;
  },
};

function createBaseStageMetrics(): StageMetrics {
  return {
    durationSeconds: 0,
    successfulWorkers: 0,
    failedWorkers: 0,
    totalWorkers: 0,
    avgCpuUsage: 0,
    avgMemoryMb: 0,
  };
}

export const StageMetrics = {
  encode(
    message: StageMetrics,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.durationSeconds !== 0) {
      writer.uint32(8).int32(message.durationSeconds);
    }
    if (message.successfulWorkers !== 0) {
      writer.uint32(16).int32(message.successfulWorkers);
    }
    if (message.failedWorkers !== 0) {
      writer.uint32(24).int32(message.failedWorkers);
    }
    if (message.totalWorkers !== 0) {
      writer.uint32(32).int32(message.totalWorkers);
    }
    if (message.avgCpuUsage !== 0) {
      writer.uint32(45).float(message.avgCpuUsage);
    }
    if (message.avgMemoryMb !== 0) {
      writer.uint32(53).float(message.avgMemoryMb);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StageMetrics {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.durationSeconds = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.successfulWorkers = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedWorkers = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalWorkers = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.avgCpuUsage = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.avgMemoryMb = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StageMetrics>): StageMetrics {
    return StageMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageMetrics>): StageMetrics {
    const message = createBaseStageMetrics();
    message.durationSeconds = object.durationSeconds ?? 0;
    message.successfulWorkers = object.successfulWorkers ?? 0;
    message.failedWorkers = object.failedWorkers ?? 0;
    message.totalWorkers = object.totalWorkers ?? 0;
    message.avgCpuUsage = object.avgCpuUsage ?? 0;
    message.avgMemoryMb = object.avgMemoryMb ?? 0;
    return message;
  },
};

/**
 * OttoscalerService - Otto-handlerì—ì„œ Ottoscalerë¡œì˜ ìŠ¤ì¼€ì¼ë§ ëª…ë ¹ ì„œë¹„ìŠ¤
 *
 * ðŸŽ¯ ëª©ì :
 * - Otto-handlerê°€ Ottoscalerì—ê²Œ Worker Pod ìŠ¤ì¼€ì¼ë§ ëª…ë ¹ì„ ì „ì†¡
 * - ìŠ¤ì¼€ì¼ë§ ìš”ì²­ì— ëŒ€í•œ ë™ê¸°ì  ì‘ë‹µ ì²˜ë¦¬
 * - Worker Pod ìƒíƒœ ì¡°íšŒ ê¸°ëŠ¥
 *
 * ðŸ“Š í†µì‹  íŒ¨í„´:
 * 1. Otto-handler â†’ ScaleUp/ScaleDown í˜¸ì¶œ â†’ Ottoscalerê°€ Worker Pod ì²˜ë¦¬
 * 2. Otto-handler â†’ GetWorkerStatus í˜¸ì¶œ â†’ í˜„ìž¬ Worker ìƒíƒœ ë°˜í™˜
 */
export type OttoscalerServiceService = typeof OttoscalerServiceService;
export const OttoscalerServiceService = {
  /**
   * ScaleUp - Worker Podë¥¼ ìƒì„±í•˜ì—¬ ìŠ¤ì¼€ì¼ ì—…
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ìƒˆë¡œìš´ CI/CD ìž‘ì—… ì‹œìž‘ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ Worker Pod ìƒì„±
   * - ìƒì„±ëœ Worker Pod ì •ë³´ë¥¼ ì‘ë‹µìœ¼ë¡œ ë°˜í™˜
   */
  scaleUp: {
    path: '/ottoscaler.v1.OttoscalerService/ScaleUp',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ScaleRequest) =>
      Buffer.from(ScaleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ScaleRequest.decode(value),
    responseSerialize: (value: ScaleResponse) =>
      Buffer.from(ScaleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScaleResponse.decode(value),
  },
  /**
   * ScaleDown - Worker Podë¥¼ ì¢…ë£Œí•˜ì—¬ ìŠ¤ì¼€ì¼ ë‹¤ìš´
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ CI/CD ìž‘ì—… ì™„ë£Œ ë˜ëŠ” ì·¨ì†Œ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ Worker Podë“¤ì„ ì •ë¦¬
   */
  scaleDown: {
    path: '/ottoscaler.v1.OttoscalerService/ScaleDown',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ScaleRequest) =>
      Buffer.from(ScaleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ScaleRequest.decode(value),
    responseSerialize: (value: ScaleResponse) =>
      Buffer.from(ScaleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScaleResponse.decode(value),
  },
  /**
   * GetWorkerStatus - í˜„ìž¬ Worker Pod ìƒíƒœ ì¡°íšŒ
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ Worker ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹¶ì„ ë•Œ í˜¸ì¶œ
   * - í™œì„± ìƒíƒœì¸ Worker Pod ëª©ë¡ê³¼ ìƒíƒœ ì •ë³´ ë°˜í™˜
   */
  getWorkerStatus: {
    path: '/ottoscaler.v1.OttoscalerService/GetWorkerStatus',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WorkerStatusRequest) =>
      Buffer.from(WorkerStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WorkerStatusRequest.decode(value),
    responseSerialize: (value: WorkerStatusResponse) =>
      Buffer.from(WorkerStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WorkerStatusResponse.decode(value),
  },
  /**
   * ExecutePipeline - CI/CD Pipeline ì‹¤í–‰
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ì „ì²´ Pipeline (build, test, deploy ë“±)ì„ ì „ë‹¬
   * - Ottoscalerê°€ Stage ì˜ì¡´ì„±ì„ íŒŒì•…í•˜ì—¬ ìˆœì°¨/ë³‘ë ¬ ì‹¤í–‰
   * - ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™©ì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ë°˜í™˜
   */
  executePipeline: {
    path: '/ottoscaler.v1.OttoscalerService/ExecutePipeline',
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: PipelineRequest) =>
      Buffer.from(PipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PipelineRequest.decode(value),
    responseSerialize: (value: PipelineProgress) =>
      Buffer.from(PipelineProgress.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PipelineProgress.decode(value),
  },
} as const;

export interface OttoscalerServiceServer extends UntypedServiceImplementation {
  /**
   * ScaleUp - Worker Podë¥¼ ìƒì„±í•˜ì—¬ ìŠ¤ì¼€ì¼ ì—…
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ìƒˆë¡œìš´ CI/CD ìž‘ì—… ì‹œìž‘ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ Worker Pod ìƒì„±
   * - ìƒì„±ëœ Worker Pod ì •ë³´ë¥¼ ì‘ë‹µìœ¼ë¡œ ë°˜í™˜
   */
  scaleUp: handleUnaryCall<ScaleRequest, ScaleResponse>;
  /**
   * ScaleDown - Worker Podë¥¼ ì¢…ë£Œí•˜ì—¬ ìŠ¤ì¼€ì¼ ë‹¤ìš´
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ CI/CD ìž‘ì—… ì™„ë£Œ ë˜ëŠ” ì·¨ì†Œ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ Worker Podë“¤ì„ ì •ë¦¬
   */
  scaleDown: handleUnaryCall<ScaleRequest, ScaleResponse>;
  /**
   * GetWorkerStatus - í˜„ìž¬ Worker Pod ìƒíƒœ ì¡°íšŒ
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ Worker ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹¶ì„ ë•Œ í˜¸ì¶œ
   * - í™œì„± ìƒíƒœì¸ Worker Pod ëª©ë¡ê³¼ ìƒíƒœ ì •ë³´ ë°˜í™˜
   */
  getWorkerStatus: handleUnaryCall<WorkerStatusRequest, WorkerStatusResponse>;
  /**
   * ExecutePipeline - CI/CD Pipeline ì‹¤í–‰
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ì „ì²´ Pipeline (build, test, deploy ë“±)ì„ ì „ë‹¬
   * - Ottoscalerê°€ Stage ì˜ì¡´ì„±ì„ íŒŒì•…í•˜ì—¬ ìˆœì°¨/ë³‘ë ¬ ì‹¤í–‰
   * - ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™©ì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ë°˜í™˜
   */
  executePipeline: handleServerStreamingCall<PipelineRequest, PipelineProgress>;
}

export interface OttoscalerServiceClient extends Client {
  /**
   * ScaleUp - Worker Podë¥¼ ìƒì„±í•˜ì—¬ ìŠ¤ì¼€ì¼ ì—…
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ìƒˆë¡œìš´ CI/CD ìž‘ì—… ì‹œìž‘ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ Worker Pod ìƒì„±
   * - ìƒì„±ëœ Worker Pod ì •ë³´ë¥¼ ì‘ë‹µìœ¼ë¡œ ë°˜í™˜
   */
  scaleUp(
    request: ScaleRequest,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  scaleUp(
    request: ScaleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  scaleUp(
    request: ScaleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  /**
   * ScaleDown - Worker Podë¥¼ ì¢…ë£Œí•˜ì—¬ ìŠ¤ì¼€ì¼ ë‹¤ìš´
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ CI/CD ìž‘ì—… ì™„ë£Œ ë˜ëŠ” ì·¨ì†Œ ì‹œ í˜¸ì¶œ
   * - Ottoscalerê°€ ì§€ì •ëœ Worker Podë“¤ì„ ì •ë¦¬
   */
  scaleDown(
    request: ScaleRequest,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  scaleDown(
    request: ScaleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  scaleDown(
    request: ScaleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScaleResponse) => void,
  ): ClientUnaryCall;
  /**
   * GetWorkerStatus - í˜„ìž¬ Worker Pod ìƒíƒœ ì¡°íšŒ
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ Worker ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹¶ì„ ë•Œ í˜¸ì¶œ
   * - í™œì„± ìƒíƒœì¸ Worker Pod ëª©ë¡ê³¼ ìƒíƒœ ì •ë³´ ë°˜í™˜
   */
  getWorkerStatus(
    request: WorkerStatusRequest,
    callback: (
      error: ServiceError | null,
      response: WorkerStatusResponse,
    ) => void,
  ): ClientUnaryCall;
  getWorkerStatus(
    request: WorkerStatusRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: WorkerStatusResponse,
    ) => void,
  ): ClientUnaryCall;
  getWorkerStatus(
    request: WorkerStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: WorkerStatusResponse,
    ) => void,
  ): ClientUnaryCall;
  /**
   * ExecutePipeline - CI/CD Pipeline ì‹¤í–‰
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Otto-handlerê°€ ì „ì²´ Pipeline (build, test, deploy ë“±)ì„ ì „ë‹¬
   * - Ottoscalerê°€ Stage ì˜ì¡´ì„±ì„ íŒŒì•…í•˜ì—¬ ìˆœì°¨/ë³‘ë ¬ ì‹¤í–‰
   * - ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™©ì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ë°˜í™˜
   */
  executePipeline(
    request: PipelineRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PipelineProgress>;
  executePipeline(
    request: PipelineRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PipelineProgress>;
}

export const OttoscalerServiceClient = makeGenericClientConstructor(
  OttoscalerServiceService,
  'ottoscaler.v1.OttoscalerService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): OttoscalerServiceClient;
  service: typeof OttoscalerServiceService;
  serviceName: string;
};

/**
 * OttoHandlerLogService - Ottoscalerì—ì„œ Otto-handlerë¡œì˜ ë¡œê·¸ ì „ë‹¬ ì„œë¹„ìŠ¤
 *
 * ðŸŽ¯ ëª©ì :
 * - Ottoscalerê°€ ìˆ˜ì§‘í•œ Worker Pod ë¡œê·¸ë¥¼ Otto-handlerë¡œ ì „ë‹¬
 * - Otto-handlerì—ì„œ ë¡œê·¸ë¥¼ ë°›ì•„ ì›¹ ì¸í„°íŽ˜ì´ìŠ¤ì— í‘œì‹œ
 * - ì‹¤ì‹œê°„ ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°ì„ í†µí•œ CI/CD ìž‘ì—… ëª¨ë‹ˆí„°ë§
 *
 * ðŸ“Š í†µì‹  íŒ¨í„´:
 * 1. Ottoscaler â†’ ForwardWorkerLogs() ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë¡œê·¸ ì „ì†¡
 * 2. Otto-handler â†’ LogForwardResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
 */
export type OttoHandlerLogServiceService = typeof OttoHandlerLogServiceService;
export const OttoHandlerLogServiceService = {
  /**
   * ForwardWorkerLogs - Worker Pod ë¡œê·¸ë¥¼ Otto-handlerë¡œ ì „ë‹¬
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Ottoscaler): WorkerLogEntryë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (Otto-handler): LogForwardResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Ottoscalerê°€ Worker Pod ë¡œê·¸ ìˆ˜ì§‘ ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ WorkerLogEntry ì „ì†¡
   * 3. Otto-handlerê°€ LogForwardResponseë¡œ ACK/RETRY ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  forwardWorkerLogs: {
    path: '/ottoscaler.v1.OttoHandlerLogService/ForwardWorkerLogs',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: WorkerLogEntry) =>
      Buffer.from(WorkerLogEntry.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WorkerLogEntry.decode(value),
    responseSerialize: (value: LogForwardResponse) =>
      Buffer.from(LogForwardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogForwardResponse.decode(value),
  },
  /**
   * NotifyWorkerStatus - Worker Pod ìƒíƒœ ë³€ê²½ ì•Œë¦¼
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Ottoscalerì—ì„œ Worker Pod ìƒíƒœ ë³€ê²½ ì‹œ í˜¸ì¶œ
   * - Otto-handlerì—ì„œ ìƒíƒœë¥¼ ë°›ì•„ UI ì—…ë°ì´íŠ¸
   */
  notifyWorkerStatus: {
    path: '/ottoscaler.v1.OttoHandlerLogService/NotifyWorkerStatus',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WorkerStatusNotification) =>
      Buffer.from(WorkerStatusNotification.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      WorkerStatusNotification.decode(value),
    responseSerialize: (value: WorkerStatusAck) =>
      Buffer.from(WorkerStatusAck.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WorkerStatusAck.decode(value),
  },
} as const;

export interface OttoHandlerLogServiceServer
  extends UntypedServiceImplementation {
  /**
   * ForwardWorkerLogs - Worker Pod ë¡œê·¸ë¥¼ Otto-handlerë¡œ ì „ë‹¬
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Ottoscaler): WorkerLogEntryë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (Otto-handler): LogForwardResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Ottoscalerê°€ Worker Pod ë¡œê·¸ ìˆ˜ì§‘ ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ WorkerLogEntry ì „ì†¡
   * 3. Otto-handlerê°€ LogForwardResponseë¡œ ACK/RETRY ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  forwardWorkerLogs: handleBidiStreamingCall<
    WorkerLogEntry,
    LogForwardResponse
  >;
  /**
   * NotifyWorkerStatus - Worker Pod ìƒíƒœ ë³€ê²½ ì•Œë¦¼
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Ottoscalerì—ì„œ Worker Pod ìƒíƒœ ë³€ê²½ ì‹œ í˜¸ì¶œ
   * - Otto-handlerì—ì„œ ìƒíƒœë¥¼ ë°›ì•„ UI ì—…ë°ì´íŠ¸
   */
  notifyWorkerStatus: handleUnaryCall<
    WorkerStatusNotification,
    WorkerStatusAck
  >;
}

export interface OttoHandlerLogServiceClient extends Client {
  /**
   * ForwardWorkerLogs - Worker Pod ë¡œê·¸ë¥¼ Otto-handlerë¡œ ì „ë‹¬
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Ottoscaler): WorkerLogEntryë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (Otto-handler): LogForwardResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Ottoscalerê°€ Worker Pod ë¡œê·¸ ìˆ˜ì§‘ ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ WorkerLogEntry ì „ì†¡
   * 3. Otto-handlerê°€ LogForwardResponseë¡œ ACK/RETRY ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  forwardWorkerLogs(): ClientDuplexStream<WorkerLogEntry, LogForwardResponse>;
  forwardWorkerLogs(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<WorkerLogEntry, LogForwardResponse>;
  forwardWorkerLogs(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<WorkerLogEntry, LogForwardResponse>;
  /**
   * NotifyWorkerStatus - Worker Pod ìƒíƒœ ë³€ê²½ ì•Œë¦¼
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Ottoscalerì—ì„œ Worker Pod ìƒíƒœ ë³€ê²½ ì‹œ í˜¸ì¶œ
   * - Otto-handlerì—ì„œ ìƒíƒœë¥¼ ë°›ì•„ UI ì—…ë°ì´íŠ¸
   */
  notifyWorkerStatus(
    request: WorkerStatusNotification,
    callback: (error: ServiceError | null, response: WorkerStatusAck) => void,
  ): ClientUnaryCall;
  notifyWorkerStatus(
    request: WorkerStatusNotification,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WorkerStatusAck) => void,
  ): ClientUnaryCall;
  notifyWorkerStatus(
    request: WorkerStatusNotification,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WorkerStatusAck) => void,
  ): ClientUnaryCall;
}

export const OttoHandlerLogServiceClient = makeGenericClientConstructor(
  OttoHandlerLogServiceService,
  'ottoscaler.v1.OttoHandlerLogService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): OttoHandlerLogServiceClient;
  service: typeof OttoHandlerLogServiceService;
  serviceName: string;
};

export type LogStreamingServiceService = typeof LogStreamingServiceService;
export const LogStreamingServiceService = {
  /**
   * StreamLogs - ì–‘ë°©í–¥ ìŠ¤íŠ¸ë¦¬ë° RPCë¡œ ë¡œê·¸ ì „ì†¡
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Worker Pod): LogEntry ë©”ì‹œì§€ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (NestJS): LogResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   * - ì—°ê²°ì´ ëŠì–´ì§€ë©´ ìžë™ìœ¼ë¡œ ìž¬ì—°ê²° ì‹œë„
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Worker Podê°€ ìŠ¤íŠ¸ë¦¼ ì—°ê²° ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ LogEntry ì „ì†¡
   * 3. ì„œë²„ê°€ LogResponseë¡œ ACK/RETRY/DROP ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  streamLogs: {
    path: '/ottoscaler.v1.LogStreamingService/StreamLogs',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: LogEntry) =>
      Buffer.from(LogEntry.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogEntry.decode(value),
    responseSerialize: (value: LogResponse) =>
      Buffer.from(LogResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogResponse.decode(value),
  },
  /**
   * RegisterWorker - Worker Pod ì‹œìž‘ ì‹œ ì„œë²„ì— ë“±ë¡
   *
   * ðŸ“‹ ë“±ë¡ í”„ë¡œì„¸ìŠ¤:
   * 1. Worker Podê°€ ì‹œìž‘ë˜ë©´ ì¦‰ì‹œ í˜¸ì¶œ
   * 2. Worker ë©”íƒ€ë°ì´í„°ì™€ ìž‘ì—… ì •ë³´ ì „ì†¡
   * 3. ì„œë²„ì—ì„œ ì„¸ì…˜ IDì™€ ë¡œê¹… ì„¤ì • ë°˜í™˜
   * 4. ì´í›„ StreamLogsì—ì„œ ì„¸ì…˜ ID ì‚¬ìš©
   */
  registerWorker: {
    path: '/ottoscaler.v1.LogStreamingService/RegisterWorker',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WorkerRegistration) =>
      Buffer.from(WorkerRegistration.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WorkerRegistration.decode(value),
    responseSerialize: (value: RegistrationResponse) =>
      Buffer.from(RegistrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegistrationResponse.decode(value),
  },
} as const;

export interface LogStreamingServiceServer
  extends UntypedServiceImplementation {
  /**
   * StreamLogs - ì–‘ë°©í–¥ ìŠ¤íŠ¸ë¦¬ë° RPCë¡œ ë¡œê·¸ ì „ì†¡
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Worker Pod): LogEntry ë©”ì‹œì§€ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (NestJS): LogResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   * - ì—°ê²°ì´ ëŠì–´ì§€ë©´ ìžë™ìœ¼ë¡œ ìž¬ì—°ê²° ì‹œë„
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Worker Podê°€ ìŠ¤íŠ¸ë¦¼ ì—°ê²° ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ LogEntry ì „ì†¡
   * 3. ì„œë²„ê°€ LogResponseë¡œ ACK/RETRY/DROP ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  streamLogs: handleBidiStreamingCall<LogEntry, LogResponse>;
  /**
   * RegisterWorker - Worker Pod ì‹œìž‘ ì‹œ ì„œë²„ì— ë“±ë¡
   *
   * ðŸ“‹ ë“±ë¡ í”„ë¡œì„¸ìŠ¤:
   * 1. Worker Podê°€ ì‹œìž‘ë˜ë©´ ì¦‰ì‹œ í˜¸ì¶œ
   * 2. Worker ë©”íƒ€ë°ì´í„°ì™€ ìž‘ì—… ì •ë³´ ì „ì†¡
   * 3. ì„œë²„ì—ì„œ ì„¸ì…˜ IDì™€ ë¡œê¹… ì„¤ì • ë°˜í™˜
   * 4. ì´í›„ StreamLogsì—ì„œ ì„¸ì…˜ ID ì‚¬ìš©
   */
  registerWorker: handleUnaryCall<WorkerRegistration, RegistrationResponse>;
}

export interface LogStreamingServiceClient extends Client {
  /**
   * StreamLogs - ì–‘ë°©í–¥ ìŠ¤íŠ¸ë¦¬ë° RPCë¡œ ë¡œê·¸ ì „ì†¡
   *
   * ðŸ“ ë™ìž‘ ë°©ì‹:
   * - Client (Worker Pod): LogEntry ë©”ì‹œì§€ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì „ì†¡
   * - Server (NestJS): LogResponseë¡œ ì²˜ë¦¬ ìƒíƒœ ì‘ë‹µ
   * - ì—°ê²°ì´ ëŠì–´ì§€ë©´ ìžë™ìœ¼ë¡œ ìž¬ì—°ê²° ì‹œë„
   *
   * ðŸ”„ ìŠ¤íŠ¸ë¦¼ ë¼ì´í”„ì‚¬ì´í´:
   * 1. Worker Podê°€ ìŠ¤íŠ¸ë¦¼ ì—°ê²° ì‹œìž‘
   * 2. ë¡œê·¸ ë°œìƒ ì‹œë§ˆë‹¤ LogEntry ì „ì†¡
   * 3. ì„œë²„ê°€ LogResponseë¡œ ACK/RETRY/DROP ì‘ë‹µ
   * 4. Worker ìž‘ì—… ì™„ë£Œ ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
   */
  streamLogs(): ClientDuplexStream<LogEntry, LogResponse>;
  streamLogs(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<LogEntry, LogResponse>;
  streamLogs(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<LogEntry, LogResponse>;
  /**
   * RegisterWorker - Worker Pod ì‹œìž‘ ì‹œ ì„œë²„ì— ë“±ë¡
   *
   * ðŸ“‹ ë“±ë¡ í”„ë¡œì„¸ìŠ¤:
   * 1. Worker Podê°€ ì‹œìž‘ë˜ë©´ ì¦‰ì‹œ í˜¸ì¶œ
   * 2. Worker ë©”íƒ€ë°ì´í„°ì™€ ìž‘ì—… ì •ë³´ ì „ì†¡
   * 3. ì„œë²„ì—ì„œ ì„¸ì…˜ IDì™€ ë¡œê¹… ì„¤ì • ë°˜í™˜
   * 4. ì´í›„ StreamLogsì—ì„œ ì„¸ì…˜ ID ì‚¬ìš©
   */
  registerWorker(
    request: WorkerRegistration,
    callback: (
      error: ServiceError | null,
      response: RegistrationResponse,
    ) => void,
  ): ClientUnaryCall;
  registerWorker(
    request: WorkerRegistration,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: RegistrationResponse,
    ) => void,
  ): ClientUnaryCall;
  registerWorker(
    request: WorkerRegistration,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: RegistrationResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const LogStreamingServiceClient = makeGenericClientConstructor(
  LogStreamingServiceService,
  'ottoscaler.v1.LogStreamingService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): LogStreamingServiceClient;
  service: typeof LogStreamingServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends { $case: string }
        ? { [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]> } & {
            $case: T['$case'];
          }
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
