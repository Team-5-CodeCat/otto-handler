name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js LTS
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'pnpm'

      - name: Setup NPM authentication for GitHub Packages
        run: |
          set -euo pipefail  # Exit on error, undefined variable, or pipe failure
          echo "@Team-5-CodeCat:registry=https://npm.pkg.github.com" > ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.OTTO_SDK_PACKAGE_TOKEN }}" >> ~/.npmrc
          echo "âœ… NPM authentication configured"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Install dependencies
        run: |
          set -euo pipefail
          pnpm install --frozen-lockfile || { echo "âŒ Failed to install dependencies"; exit 1; }
          echo "âœ… Dependencies installed successfully"

      - name: Run linting
        run: |
          set -euo pipefail
          pnpm lint || { echo "âŒ Linting failed"; exit 1; }
          echo "âœ… Linting passed"

      - name: Run type checking
        run: |
          set -euo pipefail
          npx tsc --noEmit || { echo "âŒ Type checking failed"; exit 1; }
          echo "âœ… Type checking passed"

      - name: Create .env.prod file for build
        run: |
          set -euo pipefail
          
          # Create .env.prod file with all variables
          cat > .env.prod << 'EOF' || { echo "âŒ Failed to create .env.prod file"; exit 1; }
          PORT=${{ secrets.PORT }}
          NODE_ENV=production
          COOKIE_SECRET=${{ secrets.COOKIE_SECRET }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          REDIS_URL=${{ secrets.REDIS_URL }}
          OTTO_GITHUB_APP_ID=${{ secrets.OTTO_GITHUB_APP_ID }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          EOF

          # Handle multiline GitHub App Private Key properly
          echo "OTTO_GITHUB_APP_PRIVATE_KEY=\"$(echo '${{ secrets.OTTO_GITHUB_APP_PRIVATE_KEY }}' | sed 's/$/\\n/' | tr -d '\n')\"" >> .env.prod || { echo "âŒ Failed to add private key"; exit 1; }

          # Secure the .env.prod file
          chmod 600 .env.prod || { echo "âŒ Failed to secure .env.prod file"; exit 1; }
          echo "âœ… .env.prod file created and secured"

      - name: Generate Prisma Client
        run: |
          set -euo pipefail
          pnpm db:generate || { echo "âŒ Prisma client generation failed"; exit 1; }
          echo "âœ… Prisma client generated"

      - name: Build application
        run: |
          set -euo pipefail
          pnpm build || { echo "âŒ Build failed"; exit 1; }
          echo "âœ… Application built successfully"

      - name: Upload build artifacts
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: actions/upload-artifact@v4
        with:
          name: nestjs-build
          path: |
            dist
            prisma
            package.json
            pnpm-lock.yaml
          retention-days: 7

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          command_timeout: 30m
          script_stop: true
          script: |
            #!/bin/bash
            # ============================================
            # Deployment Script for Otto Handler
            # ============================================

            # Exit immediately if any command fails
            set -euo pipefail

            # Enable error reporting
            trap 'echo "âŒ Error occurred at line $LINENO with exit code $?"' ERR

            echo "========================================="
            echo "ðŸš€ Starting deployment at $(date)"
            echo "========================================="

            # ============================================
            # 1. Environment Setup
            # ============================================

            # Setup Node.js environment
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
            [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"
            export PATH="/usr/local/bin:/usr/bin:$PATH"

            # Verify Node.js version
            if ! command -v node &> /dev/null; then
              echo "âŒ Node.js is not installed!"
              exit 1
            fi

            NODE_VERSION=$(node -v | cut -d'v' -f2 | cut -d'.' -f1)
            if [ "$NODE_VERSION" -lt 22 ]; then
              echo "ðŸ“¦ Installing Node.js 22..."
              nvm install 22
              nvm use 22
              nvm alias default 22
            fi
            echo "âœ… Node.js version: $(node --version)"

            # Install global dependencies if needed
            if ! command -v pnpm &> /dev/null; then
              echo "ðŸ“¦ Installing pnpm..."
              npm install -g pnpm@9 || exit 1
            fi
            echo "âœ… pnpm version: $(pnpm --version)"

            if ! command -v pm2 &> /dev/null; then
              echo "ðŸ“¦ Installing PM2..."
              npm install -g pm2 || exit 1
            fi
            echo "âœ… PM2 version: $(pm2 --version)"

            # ============================================
            # 2. Project Directory Setup
            # ============================================

            PROJECT_DIR="$HOME/otto-handler"
            TEMP_DIR="$HOME/otto-temp-$(date +%s)"
            APP_NAME="otto-handler"
            PORT=${{ secrets.PORT }}

            # Ensure project directory exists
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "âŒ Project directory $PROJECT_DIR does not exist"
              exit 1
            fi

            # Fix permissions if needed
            if [ ! -w "$PROJECT_DIR" ]; then
              echo "ðŸ”§ Fixing directory permissions..."
              sudo chown -R $USER:$USER "$PROJECT_DIR" || exit 1
            fi

            # ============================================
            # 3. Backup Current Deployment
            # ============================================

            echo "ðŸ“¦ Creating backup of current deployment..."
            if [ -d "$PROJECT_DIR/dist" ]; then
              cp -r "$PROJECT_DIR/dist" "$PROJECT_DIR/dist.backup" 2>/dev/null || true
              cp "$PROJECT_DIR/.env.prod" "$PROJECT_DIR/.env.prod.backup" 2>/dev/null || true
            fi

            # ============================================
            # 4. Update Code
            # ============================================

            cd "$PROJECT_DIR"

            # Store current commit for potential rollback
            PREVIOUS_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
            echo "ðŸ“Œ Current commit: $PREVIOUS_COMMIT"

            # Pull latest changes
            echo "ðŸ”„ Pulling latest changes..."
            git fetch origin main || exit 1
            git reset --hard origin/main || exit 1

            NEW_COMMIT=$(git rev-parse HEAD)
            echo "ðŸ“Œ New commit: $NEW_COMMIT"

            # ============================================
            # 5. Build in Temporary Directory
            # ============================================

            echo "ðŸ—ï¸ Creating temporary build directory..."
            cp -r "$PROJECT_DIR" "$TEMP_DIR" || exit 1
            cd "$TEMP_DIR"

            # Install dependencies
            echo "ðŸ“¦ Installing dependencies..."
            pnpm install --frozen-lockfile || {
              echo "âŒ Failed to install dependencies"
              rm -rf "$TEMP_DIR"
              exit 1
            }

            # Create .env.prod file
            echo "ðŸ” Creating .env.prod file..."
            cat > .env.prod << 'EOF'
            PORT=${{ secrets.PORT }}
            NODE_ENV=production
            COOKIE_SECRET=${{ secrets.COOKIE_SECRET }}
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            REDIS_URL=${{ secrets.REDIS_URL }}
            OTTO_GITHUB_APP_ID=${{ secrets.OTTO_GITHUB_APP_ID }}
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            EOF

            # Handle multiline GitHub App Private Key
            echo "OTTO_GITHUB_APP_PRIVATE_KEY='${{ secrets.OTTO_GITHUB_APP_PRIVATE_KEY }}'" >> .env.prod

            # Secure the .env.prod file
            chmod 600 .env.prod
            echo "âœ… .env.prod file created and secured"

            # Generate Prisma Client
            echo "ðŸ—„ï¸ Generating Prisma Client..."
            pnpm db:generate || {
              echo "âŒ Prisma generate failed"
              rm -rf "$TEMP_DIR"
              exit 1
            }

            # Run database migrations with flexible strategy
            echo "ðŸ—„ï¸ Synchronizing database schema..."
            
            # Function to check if migrations table exists
            check_migrations_table() {
              npx prisma migrate status 2>&1 | grep -q "_prisma_migrations" || return 1
            }
            
            # Function to mark migrations as baseline
            baseline_migrations() {
              echo "ðŸ“ Marking existing schema as baseline..."
              # Get list of migration directories
              if [ -d "prisma/migrations" ]; then
                for migration in prisma/migrations/*/; do
                  if [ -d "$migration" ]; then
                    migration_name=$(basename "$migration")
                    echo "  - Marking $migration_name as applied"
                  fi
                done
                
                # Use prisma migrate resolve to mark as applied
                npx prisma migrate resolve --applied "$(ls -1 prisma/migrations | tail -1)" 2>/dev/null || true
              fi
            }
            
            # Strategy 1: Try normal deployment first
            echo "ðŸ”„ Attempting standard migration deployment..."
            if pnpm db:deploy 2>&1 | tee migration.log; then
              echo "âœ… Migrations applied successfully"
            else
              # Check error type
              if grep -q "P3005" migration.log || grep -q "database schema is not empty" migration.log; then
                echo "âš ï¸ Database already has schema, attempting alternative strategies..."
                
                # Strategy 2: Check if it's a fresh database that needs baselining
                if ! check_migrations_table; then
                  echo "ðŸ“Š No migrations table found, initializing migration history..."
                  
                  # Create migrations table and mark current schema as baseline
                  npx prisma migrate deploy --skip-seed 2>&1 | tee migration_retry.log || {
                    if grep -q "P3005" migration_retry.log; then
                      # Database has schema but no migrations - need to baseline
                      echo "ðŸ”§ Creating baseline from existing schema..."
                      
                      # First, ensure schema matches current Prisma schema
                      npx prisma db:push --skip-generate --accept-data-loss=false || {
                        echo "âš ï¸ Schema drift detected, attempting safe sync..."
                        
                        # Generate a migration to capture the differences
                        npx prisma migrate dev --name "sync_production_schema" --skip-seed --skip-generate --create-only || true
                        
                        # Mark it as applied since schema already exists
                        baseline_migrations
                      }
                    fi
                  }
                else
                  # Strategy 3: Migrations table exists, check for pending migrations
                  echo "ðŸ“‹ Checking migration status..."
                  MIGRATION_STATUS=$(npx prisma migrate status 2>&1 || echo "")
                  
                  if echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then
                    echo "âœ… Database schema is already up to date"
                  elif echo "$MIGRATION_STATUS" | grep -q "Following migrations have not yet been applied"; then
                    echo "ðŸ”„ Found pending migrations, applying..."
                    
                    # Force apply pending migrations
                    npx prisma migrate deploy --skip-seed || {
                      echo "âš ï¸ Failed to apply pending migrations, using db:push as fallback..."
                      npx prisma db:push --skip-generate --accept-data-loss=false || {
                        echo "âš ï¸ Could not sync schema, but continuing deployment..."
                        echo "   Manual intervention may be required for schema updates"
                      }
                    }
                  else
                    # Strategy 4: Use db:push as final fallback
                    echo "ðŸ”§ Using db:push to ensure schema consistency..."
                    npx prisma db:push --skip-generate --accept-data-loss=false || {
                      echo "âš ï¸ db:push failed, validating current schema..."
                      
                      # Just validate that Prisma can connect and read schema
                      if npx prisma db:pull --print 2>/dev/null | grep -q "model"; then
                        echo "âœ… Database connection verified, schema readable"
                        echo "   Schema updates may need manual intervention"
                      else
                        echo "âŒ Cannot connect to database or read schema"
                        rm -rf "$TEMP_DIR"
                        exit 1
                      fi
                    }
                  fi
                fi
                
              elif grep -q "P1001" migration.log || grep -q "Can't reach database" migration.log; then
                echo "âŒ Cannot connect to database server"
                echo "   Please check DATABASE_URL and network connectivity"
                cat migration.log
                rm -rf "$TEMP_DIR"
                exit 1
                
              elif grep -q "P1009" migration.log || grep -q "database.*does not exist" migration.log; then
                echo "âŒ Database does not exist"
                echo "   Please create the database first"
                cat migration.log
                rm -rf "$TEMP_DIR"
                exit 1
                
              else
                echo "âš ï¸ Migration failed with unexpected error, attempting recovery..."
                
                # Try to at least ensure schema matches
                if npx prisma db:push --skip-generate --accept-data-loss=false; then
                  echo "âœ… Schema synchronized using db:push"
                else
                  # Final validation before giving up
                  if npx prisma validate; then
                    echo "âš ï¸ Schema validation passed, continuing with deployment"
                    echo "   Manual migration may be required post-deployment"
                  else
                    echo "âŒ Critical: Schema validation failed"
                    cat migration.log
                    rm -rf "$TEMP_DIR"
                    exit 1
                  fi
                fi
              fi
            fi
            
            # Final verification
            echo "ðŸ” Performing final schema verification..."
            if npx prisma validate; then
              echo "âœ… Database schema synchronized and validated"
            else
              echo "âš ï¸ Warning: Schema validation had issues but continuing..."
            fi

            # Build the application
            echo "ðŸ—ï¸ Building NestJS application..."
            pnpm build || {
              echo "âŒ Build failed"
              rm -rf "$TEMP_DIR"
              exit 1
            }

            # ============================================
            # 6. Deploy New Version
            # ============================================

            echo "ðŸš€ Deploying new version..."

            # Move new build to project directory
            rm -rf "$PROJECT_DIR/dist.old" 2>/dev/null || true
            [ -d "$PROJECT_DIR/dist" ] && mv "$PROJECT_DIR/dist" "$PROJECT_DIR/dist.old"
            mv "$TEMP_DIR/dist" "$PROJECT_DIR/dist" || {
              echo "âŒ Failed to deploy new build"
              # Restore backup
              [ -d "$PROJECT_DIR/dist.backup" ] && mv "$PROJECT_DIR/dist.backup" "$PROJECT_DIR/dist"
              rm -rf "$TEMP_DIR"
              exit 1
            }

            # Copy new env file
            cp "$TEMP_DIR/.env.prod" "$PROJECT_DIR/.env.prod"

            # Sync node_modules (for Prisma client)
            echo "ðŸ”„ Syncing node_modules..."
            rsync -a --delete "$TEMP_DIR/node_modules/" "$PROJECT_DIR/node_modules/" || {
              echo "âš ï¸ Failed to sync node_modules, will regenerate..."
              cd "$PROJECT_DIR"
              pnpm install --frozen-lockfile
              pnpm db:generate
            }

            # Clean up temp directory
            rm -rf "$TEMP_DIR"

            # ============================================
            # 7. PM2 Deployment
            # ============================================

            cd "$PROJECT_DIR"

            # Create logs directory
            mkdir -p "$PROJECT_DIR/logs"

            echo "ðŸ”„ Deploying with PM2..."

            # Check if process exists
            if pm2 show "$APP_NAME" &>/dev/null; then
              echo "â™»ï¸ Performing zero-downtime reload..."
              
              # Try graceful reload first
              pm2 reload "$APP_NAME" --update-env || {
                echo "âš ï¸ Reload failed, attempting restart..."
                pm2 restart "$APP_NAME" || {
                  echo "âš ï¸ Restart failed, recreating process..."
                  pm2 delete "$APP_NAME"
                  
                  # Start fresh with cluster mode
                  pm2 start dist/main.js \
                    --name "$APP_NAME" \
                    --instances max \
                    --exec-mode cluster \
                    --max-memory-restart 1G \
                    --merge-logs \
                    --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                    --error "$PROJECT_DIR/logs/error.log" \
                    --output "$PROJECT_DIR/logs/out.log" \
                    --log "$PROJECT_DIR/logs/combined.log" \
                    --time \
                    --kill-timeout 10000 \
                    --listen-timeout 10000 \
                    --max-restarts 10 \
                    --min-uptime 5000 \
                    --node-args="--max-old-space-size=2048" || {
                    
                    echo "âŒ Failed to start application"
                    # Rollback
                    if [ -d "$PROJECT_DIR/dist.old" ]; then
                      echo "ðŸ”„ Rolling back to previous version..."
                      rm -rf "$PROJECT_DIR/dist"
                      mv "$PROJECT_DIR/dist.old" "$PROJECT_DIR/dist"
                      [ -f "$PROJECT_DIR/.env.prod.backup" ] && mv "$PROJECT_DIR/.env.prod.backup" "$PROJECT_DIR/.env.prod"
                      pm2 restart "$APP_NAME" 2>/dev/null || pm2 start "pnpm run start:prod:env" --name "$APP_NAME"
                    fi
                    exit 1
                  }
                }
              }
            else
              echo "ðŸš€ Starting application for the first time..."
              
              # Start with PM2 in cluster mode
              pm2 start dist/main.js \
                --name "$APP_NAME" \
                --instances max \
                --exec-mode cluster \
                --max-memory-restart 1G \
                --merge-logs \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --error "$PROJECT_DIR/logs/error.log" \
                --output "$PROJECT_DIR/logs/out.log" \
                --log "$PROJECT_DIR/logs/combined.log" \
                --time \
                --kill-timeout 10000 \
                --listen-timeout 10000 \
                --max-restarts 10 \
                --min-uptime 5000 \
                --node-args="--max-old-space-size=2048" || {
                
                echo "âŒ Failed to start application"
                exit 1
              }
            fi

            # Save PM2 configuration
            pm2 save || echo "âš ï¸ Failed to save PM2 configuration"

            # Setup PM2 startup (if not already configured)
            if ! systemctl is-enabled pm2-$USER &>/dev/null 2>&1; then
              echo "âš™ï¸ Setting up PM2 startup..."
              pm2 startup systemd -u $USER --hp /home/$USER | tail -n 1 | sudo bash || {
                echo "âš ï¸ PM2 startup requires manual setup"
              }
            fi

            # ============================================
            # 8. Health Check
            # ============================================

            echo "ðŸ¥ Performing health check..."
            MAX_RETRIES=15
            RETRY_COUNT=0
            HEALTH_URL="http://localhost:${PORT}/health"

            # Wait for application to start
            sleep 5

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "000")
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Health check passed! Server is responding."
                break
              else
                echo "â³ Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES (HTTP $HTTP_CODE)"
                sleep 3
                RETRY_COUNT=$((RETRY_COUNT + 1))
              fi
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "âŒ Health check failed after $MAX_RETRIES attempts"
              echo "ðŸ“‹ Checking PM2 logs..."
              pm2 logs "$APP_NAME" --lines 50 --nostream
              
              # Attempt rollback
              if [ -d "$PROJECT_DIR/dist.old" ]; then
                echo "ðŸ”„ Rolling back to previous version..."
                rm -rf "$PROJECT_DIR/dist"
                mv "$PROJECT_DIR/dist.old" "$PROJECT_DIR/dist"
                [ -f "$PROJECT_DIR/.env.prod.backup" ] && mv "$PROJECT_DIR/.env.prod.backup" "$PROJECT_DIR/.env.prod"
                pm2 restart "$APP_NAME"
              fi
              exit 1
            fi

            # ============================================
            # 9. Cleanup
            # ============================================

            echo "ðŸ§¹ Cleaning up..."

            # Remove old backups
            rm -rf "$PROJECT_DIR/dist.old" 2>/dev/null || true
            rm -rf "$PROJECT_DIR/dist.backup" 2>/dev/null || true
            rm -f "$PROJECT_DIR/.env.prod.backup" 2>/dev/null || true

            # Clean PM2 logs if they're too large (>100MB)
            if [ -f "$PROJECT_DIR/logs/combined.log" ]; then
              LOG_SIZE=$(du -m "$PROJECT_DIR/logs/combined.log" | cut -f1)
              if [ "$LOG_SIZE" -gt 100 ]; then
                echo "ðŸ“‹ Rotating large log files..."
                pm2 flush "$APP_NAME"
              fi
            fi

            # ============================================
            # 10. Final Status
            # ============================================

            echo "ðŸ“Š Deployment Status:"
            pm2 show "$APP_NAME" --no-color || true

            echo "========================================="
            echo "âœ… Deployment completed successfully!"
            echo "ðŸŒ Application: https://api.codecat-otto.shop"
            echo "ðŸ“… Timestamp: $(date)"
            echo "ðŸ”– Version: $NEW_COMMIT"
            echo "========================================="

            # Exit cleanly
            exit 0

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          script_stop: true
          script: |
            # Exit on any error
            set -euo pipefail
            
            # Quick verification
            sleep 3

            # Check if PM2 process is running
            if ! pm2 show otto-handler &>/dev/null; then
              echo "âŒ PM2 process not found"
              exit 1
            fi

            # Check local health endpoint
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${{ secrets.PORT }}/health" 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" != "200" ]; then
              echo "âŒ Local health check failed (HTTP $HTTP_CODE)"
              exit 1
            fi

            # Check public endpoint (if accessible)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://api.codecat-otto.shop/health" 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Production health check passed"
            else
              echo "âš ï¸ Public endpoint returned HTTP $HTTP_CODE (may be behind firewall)"
            fi

            echo "âœ… Deployment verification completed"

  cleanup-artifacts:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Delete old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const artifactAge = 7 * 24 * 60 * 60 * 1000; // 7 days

            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner,
              repo,
              per_page: 100
            });

            const now = Date.now();
            for (const artifact of artifacts.data.artifacts) {
              const createdAt = new Date(artifact.created_at).getTime();
              if (now - createdAt > artifactAge) {
                await github.rest.actions.deleteArtifact({
                  owner,
                  repo,
                  artifact_id: artifact.id
                });
                console.log(`Deleted artifact: ${artifact.name}`);
              }
            }
